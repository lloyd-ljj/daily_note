## 常见异步方法：

1. Reactive响应式编程
2. CompletableFuture
3. ParrallelStream

---

### 1. Reactive响应式编程

响应式编程的核心是“观察者模式”。客户端发送请求和，能够立即得到一个Stream返回，客户端订阅这个Stream来接收通知。等服务端有数据时，就会往Stream上发布数据，客户端就能够收到数据了。

```
Reactive 要点

Reactive Streams的主要目标有这两个：
  管理跨异步边界的流数据交换 - 即将元素传递到另一个线程或线程池；
  确保接收方不会强制缓冲任意数量的数据，为了使线程之间的队列有界，引入了回压(Back Pressure)。

Reactive 编程开始是流程建模过程，而不是数据处理过程
工作流由 subscribe 启动，subscribe 多次就会导致多次启动流程。这与普通语言按顺序执行不一样
scheduler 是一个单线程的调度器，每个scheduler中管理的函数都是顺序执行的，阻塞函数会阻塞流水线工作。
工作函数是响应式的，观察者模式仅是实现数据驱动的技术概念，每个数据流，就称为 “Observable” 的对象。所以，到了 2.x 就改称 “Flowable” 了

不要认为响应式编程是并发的。理论上，Reactive 是数据驱动的，而不是事件驱动的。

响应式编程不是真正意义上的并发，由于每个调度器是一个线程，它管理的操作函数之间一般都不需要对数据上锁，这些函数是按数据驱动，“并发运行”的。

在数据流从上游生产者向下游消费者传输的过程中，上游生产速度大于下游消费速度，导致下游的 Buffer 溢出，这种现象就叫做 Backpressure 出现。需要强调的是：这句话的重点不在于「上游生产速度大于下游消费速度」，而在于「Buffer 溢出」。
```

#### pom

```
    <dependencies>
        <dependency>
            <groupId>io.reactivex</groupId>
            <artifactId>rxjava</artifactId>
            <version>1.3.8</version>
        </dependency>

        <!-- https://mvnrepository.com/artifact/com.google.guava/guava -->
        <dependency>
            <groupId>com.google.guava</groupId>
            <artifactId>guava</artifactId>
            <version>28.2-jre</version>
        </dependency>
    </dependencies>
```

#### TimeConsumingService

```java
package src.react.reactive;

import java.util.concurrent.Callable;

/**
 * @author lianjunjie
 * @date 2021-08-29 17:31:24
 */
public class TimeConsumingService implements Callable<String> {

    private String service_name;
    private int wait_ms;

    public TimeConsumingService(String service_name, int wait_ms, String[] depandencies) {
        this.service_name = service_name;
        this.wait_ms = wait_ms;
    }

    @Override
    public String call() throws Exception {
        Thread.sleep(wait_ms);
        return String.format("service %s exec time is: %d", service_name, wait_ms);
    }
}
```

#### ReactDemo

```java
package src.react.reactive;


import rx.Observable;
import rx.Subscriber;
import rx.schedulers.Schedulers;

/**
 * @author lianjunjie
 * @date 2021-08-26 20:01:46
 */
public class ReactiveDemo {

    public static void main(String[] args) {
        new ReactiveDemo().testAsyncCompositeJoin();
    }

    public void testAsyncCompositeJoin() {
        System.out.println("Prepare for execution：Async Composite Join");
        long startTime = System.currentTimeMillis();

        // Tasks oa-oc, both in the same thread 1
        Observable<String> oa = Observable.just("oa").observeOn(Schedulers.io()).flatMap(
                soa -> Observable.fromCallable(new TimeConsumingService("fa", 1000, new String[]{}))
        );

        Observable<String> oc = oa.flatMap(
                (String res) -> {
                    System.out.println(res);
                    System.out.println("Executed At： " + (System.currentTimeMillis() - startTime) + "ms");
                    return Observable.fromCallable(new TimeConsumingService("fc", 2000, new String[]{}));
                });

        // tasks ob -> (od,oe),  ob, od, oe have special thread 2,3,4.
        Observable<String> ob = Observable.just("ob").observeOn(Schedulers.io()).flatMap(
                sob -> Observable.fromCallable(new TimeConsumingService("fb", 2000, new String[]{}))
        );
        Observable<String> od_oe = ob.flatMap(
                (String res) -> {
                    System.out.println(res);
                    System.out.println("Executed At： " + (System.currentTimeMillis() - startTime) + "ms");
                    Observable<String> od = Observable.just("od").observeOn(Schedulers.io()).flatMap(
                            sod -> Observable.fromCallable(new TimeConsumingService("fd", 1000, new String[]{res}))
                    );
                    Observable<String> oe = Observable.just("oe").observeOn(Schedulers.io()).flatMap(
                            sod -> Observable.fromCallable(new TimeConsumingService("fe", 1000, new String[]{res}))
                    );
                    return Observable.merge(od, oe);
                });
        System.out.println("Observable build： " + (System.currentTimeMillis() - startTime) + "ms");

        // tasks join oc,(od_oe) and subscribe
        Observable.merge(oc, od_oe).toBlocking().subscribe(
                (res) -> {
                    System.out.println(res);
                    System.out.println("Executed At： " + (System.currentTimeMillis() - startTime) + "ms");
                });

        System.out.println("End executed: " + (System.currentTimeMillis() - startTime) + "ms");
    }

    public void demoHello(String... names) {
        Observable.from(names).subscribe(new Subscriber<String>() {
            @Override
            public void onCompleted() {
                System.out.println("Completed!");
            }

            @Override
            public void onError(Throwable throwable) {
                throwable.printStackTrace();
            }

            @Override
            public void onNext(String s) {
                System.out.printf("say hello: %s%n", s);
            }
        });
    }
}
```

#### result

```
Prepare for execution：Async Composite Join
Observable build： 280ms
service fa exec time is: 1000
Executed At： 1365ms
service fb exec time is: 2000
Executed At： 2330ms
service fe exec time is: 1000
Executed At： 3354ms
service fd exec time is: 1000
Executed At： 3354ms
service fc exec time is: 2000
Executed At： 3371ms
End executed: 3371ms
Disconnected from the target VM, address: '127.0.0.1:63513', transport: 'socket'
```

---

### 2. 异步编排CompletableFuture

可以优雅地避免地狱回调，支持链式调用

#### demo

```java
package src.completablefuture;

import com.google.common.util.concurrent.ThreadFactoryBuilder;

import java.util.Random;
import java.util.concurrent.*;
import java.util.function.Function;

/**
 * @author lianjunjie
 * @date 2021-08-30 14:11:33
 */
public class CompletableFutureDemo {

    private static final ExecutorService EXECUTOR = new ThreadPoolExecutor(1, 10, 10,
            TimeUnit.SECONDS, new ArrayBlockingQueue(10), new ThreadFactoryBuilder().setNameFormat("demo-pool-%d").build());

    public static void main(String[] args) throws Exception {
//        runAsync();
//        supplyAsync();
//        whenComplete();
//        thenApply();
//        handle();
//        thenAccept();
//        thenRun();
//        thenCombine();
//        thenAcceptBoth();
//        applyToEither();
      
              CompletableFuture<Integer> task1 = CompletableFuture.supplyAsync(() -> {
            try {
                TimeUnit.SECONDS.sleep(5);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            System.out.println("task1");
            return 10;
        });
        CompletableFuture<Integer> task2 = CompletableFuture.supplyAsync(() -> {
            try {
                TimeUnit.SECONDS.sleep(1);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            System.out.println("task2");
            return 10;
        });
        CompletableFuture<Integer> task3 = CompletableFuture.supplyAsync(() -> {
            try {
                TimeUnit.SECONDS.sleep(2);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            System.out.println("task3");
            return 10;
        });

//        Integer sum = task1.join() + task2.join() + task3.join();
        Integer sum = task1.get() + task2.get() + task3.get();
        System.out.println(sum);
    }

    /**
     * runAsync, no result
     *
     * @throws Exception
     */
    private static void runAsync() throws Exception {
        CompletableFuture<Void> future = CompletableFuture.runAsync(() -> {
            try {
                TimeUnit.SECONDS.sleep(1);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            System.out.println("runAsync end ...");
        }, EXECUTOR);
        future.get();
    }

    /**
     * supplyAsync, with result
     *
     * @throws Exception
     */
    private static void supplyAsync() throws Exception {
        CompletableFuture<Long> future = CompletableFuture.supplyAsync(() -> {
            try {
                TimeUnit.SECONDS.sleep(1);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            System.out.println("supplyAsync end ...");
            return System.currentTimeMillis();
        }, EXECUTOR);
        long time = future.get();
        System.out.println("time = " + time);
    }

    /**
     * whenComplete & exceptionally
     *
     * @throws Exception
     */
    private static void whenComplete() throws Exception {
        CompletableFuture<Void> future = CompletableFuture.runAsync(() -> {
            try {
                TimeUnit.SECONDS.sleep(1);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            if (new Random().nextInt() % 2 >= 0) {
                int i = 12 / 0;
            }
            System.out.println("runAsync end ...");
        }, EXECUTOR);
        System.out.println("step1 end ...");

        future.whenComplete((unused, throwable) -> System.out.println("execute end"));

        future.exceptionally(new Function<Throwable, Void>() {
            @Override
            public Void apply(Throwable throwable) {
                System.out.println("execute fail: " + throwable.getMessage());
                return null;
            }
        });
        TimeUnit.SECONDS.sleep(2);
    }

    /**
     * thenApply, only handle normal result in next task
     *
     * @throws Exception
     */
    private static void thenApply() throws Exception {
        CompletableFuture<Long> future = CompletableFuture.supplyAsync(() -> {
            long result = new Random().nextInt(100);
            System.out.println("result1 = " + result);
            return result;
        }, EXECUTOR).thenApply(t -> {
            long result = t * 5;
            System.out.println("result2 = " + result);
            return result;
        });
        long result = future.get();
        System.out.println(result);
    }

    /**
     * handle, handle result and exception in next task
     *
     * @throws Exception
     */
    private static void handle() throws Exception {
        CompletableFuture<Integer> future = CompletableFuture.supplyAsync(() -> {
            int i = 10 / 0;
            return new Random().nextInt(100);
        }, EXECUTOR).handle((param, throwable) -> {
            int result = -1;
            if (throwable == null) {
                result = param * 2;
            } else {
                System.out.println(throwable.getMessage());
            }
            return result;
        });
        System.out.println(future.get());
    }

    /**
     * thenAccept, consume previous task result without return result
     *
     * @throws Exception
     */
    private static void thenAccept() throws Exception {
        CompletableFuture<Void> future = CompletableFuture.supplyAsync(() -> {
            return new Random().nextInt(100);
        }, EXECUTOR).thenAccept(System.out::println);
        future.get();
    }

    /**
     * thenRun, continue handle task disregarding previous task result
     *
     * @throws Exception
     */
    private static void thenRun() throws Exception {
        CompletableFuture<Void> future = CompletableFuture.supplyAsync(() -> {
            return new Random().nextInt(100);
        }, EXECUTOR).thenRun(() -> {
            System.out.println("thenRun ...");
        });
        future.get();
    }

    /**
     * thenCombine, when finish two completionStage task, referring these two result to thenCombine processing
     *
     * @throws Exception
     */
    private static void thenCombine() throws Exception {
        CompletableFuture<String> future1 = CompletableFuture.supplyAsync(() -> "hello1");
        CompletableFuture<String> future2 = CompletableFuture.supplyAsync(() -> "hello2");
        CompletableFuture<String> res = future1.thenCombine(future2, (s1, s2) -> s1 + " " + s2);
        System.out.println(res.get());
    }

    /**
     * thenAcceptBoth, consume two completionStage task
     *
     * @throws Exception
     */
    private static void thenAcceptBoth() throws Exception {
        CompletableFuture<Integer> f1 = CompletableFuture.supplyAsync(() -> {
            int t = new Random().nextInt(3);
            try {
                TimeUnit.SECONDS.sleep(t);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            System.out.println("f1=" + t);
            return t;
        }, EXECUTOR);

        CompletableFuture<Integer> f2 = CompletableFuture.supplyAsync(() -> {
            int t = new Random().nextInt(3);
            try {
                TimeUnit.SECONDS.sleep(t);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            System.out.println("f2=" + t);
            return t;
        }, EXECUTOR);
        f1.thenAcceptBoth(f2, (t, u) -> System.out.println("f1=" + t + ";f2=" + u + ";"));
    }

    /**
     * applyToEither, consume the task which is completed faster, no return result
     *
     * @throws Exception
     */
    private static void applyToEither() throws Exception {
        CompletableFuture<Integer> f1 = CompletableFuture.supplyAsync(() -> {
            int t = new Random().nextInt(3);
            try {
                TimeUnit.SECONDS.sleep(t);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            System.out.println("f1=" + t);
            return t;
        }, EXECUTOR);
        CompletableFuture<Integer> f2 = CompletableFuture.supplyAsync(() -> {
            int t = new Random().nextInt(3);
            try {
                TimeUnit.SECONDS.sleep(t);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            System.out.println("f2=" + t);
            return t;
        }, EXECUTOR);

        CompletableFuture<Integer> result = f1.applyToEither(f2, t -> {
            System.out.println(t);
            return t * 2;
        });

        System.out.println(result.get());
    }

    /**
     * acceptEither, consume the task which is completed faster, with return result
     *
     * @throws Exception
     */
    private static void acceptEither() throws Exception {
        CompletableFuture<Integer> f1 = CompletableFuture.supplyAsync(() -> {
            int t = new Random().nextInt(3);
            try {
                TimeUnit.SECONDS.sleep(t);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            System.out.println("f1=" + t);
            return t;
        });

        CompletableFuture<Integer> f2 = CompletableFuture.supplyAsync(() -> {
            int t = new Random().nextInt(3);
            try {
                TimeUnit.SECONDS.sleep(t);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            System.out.println("f2=" + t);
            return t;
        });
        f1.acceptEither(f2, t -> System.out.println(t));
    }

    /**
     * runAfterBoth, both completionStage task finished and execute next stage
     *
     * @throws Exception
     */
    private static void runAfterBoth() throws Exception {
        CompletableFuture<Integer> f1 = CompletableFuture.supplyAsync(() -> {
            int t = new Random().nextInt(3);
            try {
                TimeUnit.SECONDS.sleep(t);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            System.out.println("f1=" + t);
            return t;
        });

        CompletableFuture<Integer> f2 = CompletableFuture.supplyAsync(() -> {
            int t = new Random().nextInt(3);
            try {
                TimeUnit.SECONDS.sleep(t);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            System.out.println("f2=" + t);
            return t;
        });
        f1.runAfterBoth(f2, () -> System.out.println("上面两个任务都执行完成了。"));
    }

    /**
     * task group operation
     *
     * @throws Exception
     */
    private static void taskGroup() throws Exception {
        CompletableFuture<String> task1 = CompletableFuture.completedFuture("1");
        CompletableFuture<String> task2 = CompletableFuture.completedFuture("2");
        CompletableFuture<String> task3 = CompletableFuture.completedFuture("3");

        // any one complete will trigger
        CompletableFuture<Object> anyTask = CompletableFuture.anyOf(task1, task2, task3);
        anyTask.join();

        // all complete will trigger
        CompletableFuture<Void> allTask = CompletableFuture.allOf(task1, task2, task3);
        allTask.join();
    }

    private static void integrateTask() throws Exception {

        CompletableFuture<String> task1 = CompletableFuture.completedFuture("abc");
        CompletableFuture<String> task2 = CompletableFuture.completedFuture("cde");

        //设置task1执行完成后的后续执行过程
        CompletableFuture<Void> nextTask1 = task1.thenRun(() -> System.out.println("Done"));
        //设置task1、task2执行完成后的后续执行过程
        CompletableFuture<Void> nextTask2 = task1.runAfterBoth(task2, () -> System.out.println("Task1、Task2 All Done"));
        //设置task1执行完成后的后续处理流程
        CompletableFuture<Void> nextTask3 = task1.thenAccept(System.out::println);
        //设置task1、task2执行完成后的后续处理流程
        CompletableFuture<Void> nextTask4 = task1.thenAcceptBoth(task2, (x, y) -> System.out.println(x + y));
        //设置task1执行完成后的后续转换流程（转换成一个新的任务）
        CompletableFuture<String> nextTask5 = task1.thenApply(String::toUpperCase);
        //设置task1执行完成后的后续转换流程（转换成一个新的任务，同thenAcceptBoth(..)作用，唯一区别是任务的返回结果类型可以自定义）
        CompletableFuture<String> nextTask6 = task1.thenCompose(g -> {
            return CompletableFuture.supplyAsync(g::toUpperCase);
        });
        //设置task1、task2执行完成后的后续转换流程
        CompletableFuture<String> nextTask7 = task1.thenCombine(task2, (x, y) -> x + y);
    }
}

```

#### focus

```java
    /**
     * task group operation
     *
     * @throws Exception
     */
    private static void taskGroup() throws Exception {
        CompletableFuture<String> task1 = CompletableFuture.completedFuture("1");
        CompletableFuture<String> task2 = CompletableFuture.completedFuture("2");
        CompletableFuture<String> task3 = CompletableFuture.completedFuture("3");

        // any one complete will trigger
        CompletableFuture<Object> anyTask = CompletableFuture.anyOf(task1, task2, task3);
        anyTask.join();

        // all complete will trigger
        CompletableFuture<Void> allTask = CompletableFuture.allOf(task1, task2, task3);
        allTask.join();
    }

    private static void integrateTask() throws Exception {

        CompletableFuture<String> task1 = CompletableFuture.completedFuture("abc");
        CompletableFuture<String> task2 = CompletableFuture.completedFuture("cde");

        //设置task1执行完成后的后续执行过程
        CompletableFuture<Void> nextTask1 = task1.thenRun(() -> System.out.println("Done"));
        //设置task1、task2执行完成后的后续执行过程
        CompletableFuture<Void> nextTask2 = task1.runAfterBoth(task2, () -> System.out.println("Task1、Task2 All Done"));
        //设置task1执行完成后的后续处理流程
        CompletableFuture<Void> nextTask3 = task1.thenAccept(System.out::println);
        //设置task1、task2执行完成后的后续处理流程
        CompletableFuture<Void> nextTask4 = task1.thenAcceptBoth(task2, (x, y) -> System.out.println(x + y));
        //设置task1执行完成后的后续转换流程（转换成一个新的任务）
        CompletableFuture<String> nextTask5 = task1.thenApply(String::toUpperCase);
        //设置task1执行完成后的后续转换流程（转换成一个新的任务，同thenAcceptBoth(..)作用，唯一区别是任务的返回结果类型可以自定义）
        CompletableFuture<String> nextTask6 = task1.thenCompose(g -> {
            return CompletableFuture.supplyAsync(g::toUpperCase);
        });
        //设置task1、task2执行完成后的后续转换流程
        CompletableFuture<String> nextTask7 = task1.thenCombine(task2, (x, y) -> x + y);
    }
```

---

### 3. ParallelStream

steam既不是一种数据结构也不用于存放数据，常用于集合的逻辑处理。强大之处在于通过简单的链式编程，完成对数据的处理。可以通过多线程的方式充分发挥多核处理器的计算能力。

parallelStream提供了流的并行处理，它

是Stream的另一重要特性，其底层使用Fork/Join框架实现。简单理解就是多线程异步任务的一种实现。

集合进行并行计算有两种方式:要么将其转化为并行流，利用map这样的操作开展工作，要么枚举出集合中的每一个元素，创建新的线程，在Completable- Future内对其进行操作。后者提供了更多的灵活性，你可以调整线程池的大小，而这能帮助你确保整体的计算不会因为线程都在等待I/O而发生阻塞。
我们对使用这些API的建议如下。

- 如果你进行的是计算密集型的操作，并且没有I/O，那么推荐使用Stream接口，因为实现简单，同时效率也可能是最高的(如果所有的线程都是计算密集型的，那就没有必要创建比处理器核数更多的线程)。
- 反之，如果你并行的工作单元还涉及等待I/O的操作(包括网络连接等待)，那么使用CompletableFuture灵活性更好，你可以像前文讨论的那样，依据等待/计算，或者 W/C的比率设定需要使用的线程数。这种情况不使用并行流的另一个原因是，处理流的 流水线中如果发生I/O等待，流的延迟特性会让我们很难判断到底什么时候触发了等待。
  

